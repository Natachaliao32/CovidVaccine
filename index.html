<html>

<head>
  <title>GRAPH</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(#9EE8FF, #BDF4C3);
    }

    canvas {
      /* width: 100%; */
      /* height: 100% */
      margin: 0 auto;
    }
  </style>
</head>

<body>
  <div id="globe"></div>
  <script src="js/three.js"></script>
  <script language="JavaScript" type="text/javascript" src="js/jquery-3.6.0.min.js"></script>

  <script>

    // couple of constants
    var POS_X = 1800;
    var POS_Y = 500;
    var POS_Z = 1800;
    // var WIDTH = 1000;
    // var HEIGHT = 600;
    var PLANETRADIUS = 400;
    var WIDTH = window.innerWidth;
    var HEIGHT = window.innerHeight;

    var FOV = 45;
    var NEAR = 1;
    var FAR = 4000;

    // some global variables and initialization code
    // simple basic renderer
    var renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(WIDTH, HEIGHT);
    renderer.setClearColor(0x000000, 0);
    // turn on shadows
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

    // add it to the target element
    var mapDiv = document.getElementById("globe");
    mapDiv.appendChild(renderer.domElement);

    // setup a camera that points to the center
    var camera = new THREE.PerspectiveCamera(FOV, WIDTH / HEIGHT, NEAR, FAR);    
    // var camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 1, 1000 );

    camera.position.set(POS_X, POS_Y, POS_Z);
    camera.lookAt(new THREE.Vector3(0, 0, 0));

    // create a basic scene and add the camera
    var scene = new THREE.Scene();
    scene.add(camera);

    // we wait until the document is loaded before loading the
    // density data.
    $(document).ready(function () {
      jQuery.get('data.csv', function (data) {
        addDensity(CSVToArray(data));
        addLights();
        addEarth();
        addClouds();
        render();
      });
    });

    // add the earth
    function addEarth() {
      var spGeo = new THREE.SphereGeometry(PLANETRADIUS, 50, 50);
      var planetTexture = new THREE.TextureLoader().load("textures/earthmap.png")//THREE.ImageUtils.loadTexture("textures/2_no_clouds_4K.jpg");
      var mat2 = new THREE.MeshPhongMaterial({
        map: planetTexture,
        shininess: 0.2
      });
      sp = new THREE.Mesh(spGeo, mat2);
      // receive shadow and does not cast
      sp.receiveShadow = true; //default
      sp.castShadow = true;
      scene.add(sp);
    }

    // add clouds
    function addClouds() {
      var spGeo = new THREE.SphereGeometry(PLANETRADIUS, 50, 50);
      var cloudsTexture = new THREE.ImageUtils.loadTexture("textures/fair_clouds_4k.png");
      var materialClouds = new THREE.MeshPhongMaterial({ color: 0xffffff, map: cloudsTexture, transparent: true, opacity: 0.3 });

      meshClouds = new THREE.Mesh(spGeo, materialClouds);
      meshClouds.scale.set(1.015, 1.015, 1.015);
      scene.add(meshClouds);
    }

    // add a simple light
    function addLights() {
      //Ambiante
      light = new THREE.AmbientLight( 0x888888 );
      scene.add( light );

      light = new THREE.DirectionalLight(0xffffff, 0.5);
      light.castShadow = true;
      light.position.set(POS_X, POS_Y, POS_Z);
      scene.add(light);
      //Set up shadow properties for the light
      light.shadow.mapSize.width = 512; // default
      light.shadow.mapSize.height = 512; // default
      light.shadow.camera.near = 0.5; // default
      light.shadow.camera.far = 4000; // default

      
      //Create a helper for the shadow camera (optional)
      // const helper = new THREE.CameraHelper( light.shadow.camera );
      // scene.add( helper );
    }

    // convert CVS file to array
    function CSVToArray(strData, strDelimiter) {
      // Check to see if the delimiter is defined. If not,
      // then default to comma.
      strDelimiter = (strDelimiter || ";");

      // Create a regular expression to parse the CSV values.
      var objPattern = new RegExp(
        (
          // Delimiters.
          "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

          // Quoted fields.
          "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

          // Standard fields.
          "([^\"\\" + strDelimiter + "\\r\\n]*))"
        ),
        "gi"
      );


      // Create an array to hold our data. Give the array
      // a default empty first row.
      var arrData = [[]];

      // Create an array to hold our individual pattern
      // matching groups.
      var arrMatches = null;


      // Keep looping over the regular expression matches
      // until we can no longer find a match.
      while (arrMatches = objPattern.exec(strData)) {

        // Get the delimiter that was found.
        var strMatchedDelimiter = arrMatches[1];

        // Check to see if the given delimiter has a length
        // (is not the start of string) and if it matches
        // field delimiter. If id does not, then we know
        // that this delimiter is a row delimiter.
        if (
          strMatchedDelimiter.length &&
          strMatchedDelimiter !== strDelimiter
        ) {

          // Since we have reached a new row of data,
          // add an empty row to our data array.
          arrData.push([]);

        }

        var strMatchedValue;

        // Now that we have our delimiter out of the way,
        // let's check to see which kind of value we
        // captured (quoted or unquoted).
        if (arrMatches[2]) {

          // We found a quoted value. When we capture
          // this value, unescape any double quotes.
          strMatchedValue = arrMatches[2].replace(
            new RegExp("\"\"", "g"),
            "\""
          );

        } else {

          // We found a non-quoted value.
          strMatchedValue = arrMatches[3];

        }


        // Now that we have our value string, let's add
        // it to the data array.
        arrData[arrData.length - 1].push(strMatchedValue);
      }

      // Return the parsed data.
      return (arrData);
    }

    // convert the positions from a lat, lon to a position on a sphere.
    function latLongToVector3(lat, lon, radius, heigth) {
      var phi = (lat) * Math.PI / 180;
      var theta = (lon - 180) * Math.PI / 180;

      var x = -(radius + heigth) * Math.cos(phi) * Math.cos(theta);
      var y = (radius + heigth) * Math.sin(phi);
      var z = (radius + heigth) * Math.cos(phi) * Math.sin(theta);

      return new THREE.Vector3(x, y, z);
    }

    function createCustomCylinder(size, radius, mat, position) {
      var geo = new THREE.CylinderGeometry(radius, radius, size, 10, 1);
      geo.applyMatrix4( new THREE.Matrix4().makeTranslation ( 0, -size/2, 0 ) );
      geo.applyMatrix4( new THREE.Matrix4().makeRotationX( Math.PI / 2 ) );
      var cylinder = new THREE.Mesh(geo, mat);
      cylinder.castShadow = true;
      cylinder.receiveShadow = true; //default
      cylinder.position.set( position.x, position.y, position.z );
      cylinder.lookAt(new THREE.Vector3(0, 0, 0));
      scene.add(cylinder);
    }

    function getCol(matrix, col){
       var column = [];
       for(var i=0; i<matrix.length; i++){
          column.push(matrix[i][col]);
       }
       return column;
    }

    function getMaxFakenewsIndex(v, f) {
      var max = -1;
      var r = [-1];
      for(var i = 1; i < v.length - 1 ; i++) {
        if(typeof v[i] === "number") {
          r.push(f[i] / v[i]);
          max = r[i-1] > r[i] ? r[i-1] : r[i];
        }
      }
      return max;
    }

    // simple function that converts the density data to the markers on screen
    // the height of each marker is relative to the density.
    // takes into account one line of category titles
    function addDensity(data) {

      // the geometry that will contain all our cubes
      var geom = new THREE.BufferGeometry(); //THREE.Geometry();

      // get max size
      var vcpy = getCol(data, 3).slice();
      vcpy.shift();
      vcpy.pop();
      var vcpy2 = vcpy.map(x => parseFloat(x.replace(',', '.')));
      var vmax = Math.max(...vcpy2);
      console.log("vmax : "+vmax);

      // get max fakenews index
      var fcpy = getCol(data, 4).slice();
      fcpy.shift();
      fcpy.pop();
      var fcpy2 = fcpy.map(x => parseFloat(x.replace(',', '.')));
      var fmax = getMaxFakenewsIndex(vcpy2, fcpy2);
      console.log("fmax : "+fmax);

      for (var i = 1; i < data.length - 1; i++) {

        var padding = 5;
        var glass = new THREE.MeshLambertMaterial({ color: 0xffffff, opacity: 0.1, emissive: 0xffffff, transparent: true });
        var metal = new THREE.MeshLambertMaterial({ color: 0x000000, opacity: 0.6, emissive: 0x363636 });

        // syringe body
        // get the data
        var x = parseInt(data[i][1]); // longitude
        var y = parseInt(data[i][2]); // latitude
        var nbvaccinated = parseFloat(data[i][3].replace(',', '.'));
        // syringe body size goes from 10 to 510
        var size = 10 + 500 / vmax * nbvaccinated;
        var findex = parseFloat(data[i][4].replace(',', '.')) / nbvaccinated / fmax;
        // color
        var syrbodyMat = new THREE.MeshLambertMaterial({ color: 0x000000, opacity: 0.6, emissive: 0x000000 });
        var syrbodyColor = new THREE.Color("#90E0EF"); // blue
        syrbodyColor.lerp(new THREE.Color("#EE2E31"), findex);
        syrbodyMat.color.set(syrbodyColor);
        // radius
        var radius = 10;
        // calculate the position where we need to start the body of the syringe
        var position = latLongToVector3(y, x, PLANETRADIUS + needlesize + padding, 2);

        createCustomCylinder(size, radius, syrbodyMat, position);

        // glass container
        var containersize = size+padding+20;
        var containeradius = radius+padding;
        var containerposition = latLongToVector3(y, x, PLANETRADIUS + needlesize, 2);
        createCustomCylinder(containersize, containeradius, glass, containerposition);

        // glass plunger (tube)
        var plungertsize = 20;
        var plungertradius = 10;
        var plungertposition = latLongToVector3(y, x, PLANETRADIUS + needlesize + containersize, 2);
        createCustomCylinder(plungertsize, plungertradius, glass, plungertposition);

        // glass plunger (extremity)
        var plungeresize = 5;
        var plungereradius = containeradius;
        var plungereposition = latLongToVector3(y, x, PLANETRADIUS + needlesize + containersize + plungertsize, 2);
        createCustomCylinder(plungeresize, plungereradius, glass, plungereposition);

        // needle
        var needlesize = 20;
        var needleradius = 2;
        var needleposition = latLongToVector3(y, x, PLANETRADIUS, 2);
        createCustomCylinder(needlesize, needleradius, metal, needleposition);

        // var needlegeo = new THREE.CylinderGeometry(needleradius, needleradius, needlesize, 10, 1);
        // needlegeo.applyMatrix4( new THREE.Matrix4().makeTranslation ( 0, needlesize/2, 0 ) );
        // needlegeo.applyMatrix4( new THREE.Matrix4().makeRotationX( Math.PI / 2 ) );
        // var needle = new THREE.Mesh(needlegeo, needlemat);
        // needle.position.set( position.x, position.y, position.z ); // position;
        // needle.lookAt(new THREE.Vector3(0, 0, 0));
        // scene.add(needle);

        // create the cube
        // var cube = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 1 + size / 8, 1, 1, 1, cubeMat)); // CubeGeometry deprecated
        // var cubegeo = new THREE.BoxGeometry( 10, 10, 1 + size / 8, 1, 1, 1 );
        // var cubegeo = new THREE.CylinderGeometry( radius, radius, size, 10, 1 );
        // cubegeo.applyMatrix4( new THREE.Matrix4().makeTranslation ( 0, 1-size/2, 0 ) );
        // cubegeo.applyMatrix4( new THREE.Matrix4().makeRotationX( Math.PI / 2 ) );
        // var cube = new THREE.Mesh( cubegeo, cubeMat );

        // position the cube correctly
        // cube.position.set( position.x, position.y, position.z ); // position;

        // cube.lookAt(new THREE.Vector3(0, 0, 0));

        // console.log(size+" / "+radius+" / "+position.x+" / "+position.y+" / "+position.z);


        // merge
        // var singleGeometry = new THREE.BufferGeometry();
        // cube.updateMatrix();
        // singleGeometry.merge(cube.geometry, cube.matrix);
        // needle.updateMatrix();
        // singleGeometry.merge(needle.geometry, needle.matrix);
        // var syringe = new THREE.Mesh(singleGeometry, cubeMat); // new THREE.MeshFaceMaterial() removed, use array instead
        // scene.add(syringe);

        // merge with main model
        // THREE.GeometryUtils.merge(geom, cube); deprecated
        // cube.updateMatrix();

        // console.log(cube.geometry);
        // geom.merge(cube.geometry, cube.matrix);
        // geom.merge(cube.geometry);
        // THREE.BufferGeometryUtils.mergeBufferGeometries([geom, cube.geometry]);
        // scene.add(cube)
      }

      // create a new mesh, containing all the other meshes.
      // var total = new THREE.Mesh(geom, new THREE.MeshLambertMaterial({ color: 0xff000 })); // new THREE.MeshFaceMaterial() removed, use array instead
      // and add the total mesh to the scene
      // scene.add(total);
    }

    // render
    function render() {
      var timer = Date.now() * 0.0001;
      camera.position.x = (Math.cos(timer) * 1800);
      camera.position.z = (Math.sin(timer) * 1800);
      camera.lookAt(scene.position);
      // light.position = camera.position;
      light.lookAt(scene.position);
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

  </script>

</body>

</html>